package com.hulin;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

/**
 * Sentinel
 *     和Hystrix类似，用于服务限流、降级、熔断等 并且包含前台8080和后台（运行jar包启动），而Hystrix的后台需要自己搭建一个模块
 *     另外sentinel监控中提供对服务的限流 降级 熔断等直接操作
 * Sentinel 8080端 监控该服务
 *     1.运行Sentinel的jar包 相当于启动Sentinel后台
 *     2.被监控服务需要引入nacos、sentinel的jar包
 *     3.被监控服务的配置文件  将该服务配置到nacos配置中心中和sentinel监控中
 *     4.启动被监控服务
 *     5. http://localhost:8401进入Sentinel监控台
 *     由于Sentinel监控是采用的懒加载，当服务启动后 并不会马上进行监控 只有该服务执行过一次请求后才开始监控
 * 在Sentinel监控中对服务中每个接口（对应着资源名）配置限流
 *     流控模式
 *          直接（也是默认选项）
 *              QPS：每秒请求次数
 *              线程数：指不限制请求次数 但是请求过来之后只有这么多线程数处理请求 超过线程数的请求会直接执行流控效果
 *              对本资源进行限流
 *          关联
 *            资源A 关联资源B 然后选定的QPS限流是针对B，当B达到该限流阈值时，资源A会执行流控效果
 *     流控效果
 *          快速失败
 *              当达到限流阈值 则直接返回Sentinel的默认结果
 *          预热
 *              对资源A 选定QPS 单机阈值数10 流控模式为直接 流控效果为预热 预热时长为5
 *              表示在5秒之前，该服务只能承担10/3(coldFactor 为默认值)的请求次数 当5秒后 就可以承受10的请求次数
 *              应用场景：
 *                  秒杀系统在开启瞬间，会有很多流量上来，很有可能把系统打死，预热方式就是为了保护系统，可慢慢的把流量放进来
 *                  慢慢的把阈值增长到设置的阈值
 *          排队等待
 *             均匀排队 阈值必须设置为QPS，也就是说不限制请求次数，但是请求进来了会进行排队等待 只能每次均匀处理多少请求
 *             单机阈值数代表每秒处理多少请求，超时时间代表等待的超时时间
 *             应用场景
 *                  用于处理间隔性突发的流量。这样可以平衡时间的一直在处理请求 而不是某时间很空闲 某时间很繁忙处理请求
 * 在Sentinel监控中对服务中每个接口（对应着资源名）配置降级
 *      Sentinel的断路器是没有半开状态的
 *      降级策略
 *          RT
 *             秒级平均响应时间
 *             假设配置RT时间200ms（上限默认是4900） 和时间窗口1s
 *             则当每秒请求数>=5 且每个请求处理时间均>=200ms时，触发降级（返回默认兜底结果 该处也就意味着直接熔断）
 *             在触发降级时，时间窗口1s内该服务都会调用失败，时间窗口期过后 熔断器才关闭 正常恢复
 *          异常比例
 *              当资源的每秒请求量>=5,且每秒异常总数占通过量的比值超过阈值后 资源进入降级状态，即在接下的时间窗口内，对这个方法的调用
 *              都自动返回。
 *              当请求一个肯定有异常的方法时，如果每秒请求量没有>=5,则调用该方法不会走降级，会直接把异常报错信息返回
 *          异常数
 *              当资源近1分钟的异常数超过阈值之后会进行熔断
 *              即异常数（分钟统计）超过阈值时 触发降级（断路器打开） 当时间窗口（>=60秒）结束 则关闭降级
 *              在触发降级前，如果请求的方法会有异常 则会直接返回异常报错的信息
 *          热点key限流（热点规则）
 *              热点即经常访问的数据，很多时候我们希望统计某个热点数据中访问频次最高的top k数据，并对其访问进行限制
 *              热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。
 *              资源名不再是方法的请求地址 而是 @SentinelResource中value的值 参数索引假设配成0 代表对该请求中携带的第一个参数做限流配置
 *              限流配置只能是QPS，假设单机阈值设为1
 *              则当对该方法请求且携带了第一个参数的请求 每秒超过了1次，马上降级处理 并且返回自定义的兜底方法
 *              参数例外项
 *                  在上面对某个参数进行限流的基础上 增加参数例外项的配置 即可配置上述参数的值为多少时的单独限流阈值
 *                  也就是说当参数值为该值时，阈值是另外一个值 当不为该值时 则阈值是沿用上面配置的阈值
 * Sentinel系统规则
 *      上面的规则都是针对某一个请求接口，而系统规则配置是对整个系统生效
 *      假设阈值类型为入口qps 可设定阈值
 * Sentinel持久化规则
 *      一旦我们重启服务，sentinel规则将消失，生产环境需要将配置规则进行持久化
 *      解决方案
 *          将限流配置规则持久化进nacos保存（即在nacos创建一个配置），只要刷新8401某个rest地址，sentinel控制台的流控规则就能看到
 *          只要nacos里面的配置不删除，针对8401上sentinel上的流控规则持续有效
 *      步骤
 *          1.8401增加sentinel-datasource-nacos的jar包
 *          2.yml配置文件增加datasource配置 nacos数据源的配置
 *          3.nacos中增加限流配置
 *          4.当8401在sentinel中的限流规则持久化到nacos后 8401停止后，sentinel中的限流规则会清空
 *          但是8401重启时，sentinel又会自动从nacos中读取该限流规则
 *
 *
 *
 *
 */
@SpringBootApplication
@EnableDiscoveryClient
public class SentinelServiceMain8401 {
    public static void main(String[] args) {
        SpringApplication.run(SentinelServiceMain8401.class,args);
    }
}
